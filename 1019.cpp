//1019 数字黑洞 (20 分)
//给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 6174，这个神奇的数字也叫 Kaprekar 常数。
//
//例如，我们从6767开始，将得到
//
//7766 - 6677 = 1089
//9810 - 0189 = 9621
//9621 - 1269 = 8352
//8532 - 2358 = 6174
//7641 - 1467 = 6174
//... ...
//现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。
//
//输入格式：
//输入给出一个 (0,10^4) 区间内的正整数 N。
//
//输出格式：
//如果 N 的 4 位数字全相等，则在一行内输出 N - N = 0000；否则将计算的每一步在一行内输出，直到 6174 作为差出现，输出格式见样例。注意每个数字按 4 位数格式输出。
//
//输入样例 1：
//6767
//输出样例 1：
//7766 - 6677 = 1089
//9810 - 0189 = 9621
//9621 - 1269 = 8352
//8532 - 2358 = 6174
//输入样例 2：
//2222
//输出样例 2：
//2222 - 2222 = 0000
//


//思路	                                        表示
//输出形式为四位，当不足四位时前面用0补         ||printf("%0md",n); 表示将n输出成m位，当不够m位时用0补在前面
//要用四位数的数组成的最大的数减去组成的最小的数||先将数的四位分离存储在数组中并进行排序，然后在对数组中的数字进行组成最大和最小的数

#include <stdio.h>
void f(int a[],int*max,int*min);
int main()
{
	int n;
	scanf("%d",&n);
	int a[4];
	int max,min;
	int*pmax=&max;
	int*pmin=&min;
	while(n!=6174&&n!=0)		//加一个n！=0为了解决2222-2222=0；的特例 
	{
		for(int i=0;i<4;i++)
		{
			a[i]=n%10;
			n/=10;
		}
		f(a,pmax,pmin);
		n=max-min;		
		printf("%04d -%04d = %04d\n",max,min,n);	//printf("%0md",n); 表示将n输出成m位，当不够m位时用0补在前面
	} 
	
	
	

	return 0;
}
void f(int a[],int*pmax,int*pmin)
{
	int min=0,max=0;
	for(int i=0;i<4;i++)
	{
		for(int j=i+1;j<4;j++)
		{
			if(a[i]<a[j])
			{
				int t=a[i];
				a[i]=a[j];
				a[j]=t;
			}
		}
		max=(max)*10+a[i];
	}
	for(int i=0;i<4;i++)
	{
		for(int j=i+1;j<4;j++)
		{
			if(a[i]>a[j])
			{
				int t=a[i];
				a[i]=a[j];
				a[j]=t;
			}
		}
		min=(min)*10+a[i];
		*pmin=min; *pmax=max;
	}
}
