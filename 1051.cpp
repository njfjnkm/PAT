//1051. 复数乘法 (15)-PAT乙级真题
//复数可以写成(A + Bi)的常规形式，其中A是实部，B是虚部，i是虚数单位，满足i2 = -1；也可以写成极坐标下的指数形式(R*e(Pi))，其中R是复数模，P是辐角，i是虚数单位，其等价于三角形式(R(cos(P) + isin(P))。
//现给定两个复数的R和P，要求输出两数乘积的常规形式。
//输入格式：
//输入在一行中依次给出两个复数的R1, P1, R2, P2，数字间以空格分隔。
//输出格式：
//在一行中按照“A+Bi”的格式输出两数乘积的常规形式，实部和虚部均保留2位小数。注意：如果B是负数，则应该写成“A-|B|i”的形式。
//输入样例：
//2.3 3.5 5.2 0.4
//输出样例：
//-8.68-8.23i
//分析：当A或者B小于0但是大于-0.005(比如-0.00001)时候，如果按照A>=0的判断，
//会输出“-0.00”这样的结果,事实上应该输出“0.00”【B同理，应该输出“+0.00i”】

//这道题有个坑，就是由于要保留最后的两位小数，如果A或B的绝对值<0.01，则会被截断为0.00或-0.00，
//问题就出在这个-0.00上面。会导致最后两个测试点过不去。
//我们可以通过当A或B的绝对值小于0.01时，直接将其置零的操作来解决这个问题

//总结：
//1、一个普遍的坑是没有判定实部与虚部的绝对值是否小于0.01，例如-0.003-0.004i是要输出0.00+0.00i的。
//2、此题并不需要实部为零或者虚部为零时省略实部或虚部。
//3、我一开始所有变量设置为float类型，最后一个测试点不通过，后来发现在C++中，fabs()函数接受double类型参数并返回double类型参数，与我的float参数不符，这算是踩了一个奇怪的坑。更改为fabsf()或者把所有参数都改为double均可以解决问题。
//4,正数乘以负数会自动带上负号,负数乘以负数会自动去掉负号 


#include <iostream>
#include <cmath>		//使用了绝对值fabs函数和三角函数sin，cos 

using namespace std;

int main() 
{
    double r1, p1, r2, p2, a, b, c, d, A, B;		//A是乘积的实部，B是乘积的虚部 
    scanf("%lf%lf%lf%lf", &r1, &p1, &r2, &p2);
    a = r1 * cos(p1);
    b = r1 * sin(p1);
    c = r2 * cos(p2);
    d = r2 * sin(p2);
    A = a * c - b * d;
    B = a * d + b * c;
    if (fabs(A) < 0.01) A = 0;		//double accuracy=0.01;
    if (fabs(B) < 0.01) B = 0;
    if (B >= 0)		
        printf("%.2f+%.2fi", A, B);
    else
        printf("%.2f%.2fi", A, B);
    return 0;
}
